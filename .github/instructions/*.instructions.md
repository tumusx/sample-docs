## Pull Request Review Scope

### Files to review
Only review files under:
- composeApp/src/commonMain/**
- composeApp/src/iosMain/**
- composeApp/src/commonTest/**

### Files to ignore
Ignore completely:
- **/build/**
- **/.gradle/**
- **/.idea/**
- **/iosApp/**
- **/composeApp/src/**/generated/**
- generated files
- configuration-only changes

---

## Review Guidelines

### Naming Conventions
**MANDATORY** - Always check and enforce:
- **Classes, Interfaces, and Objects**: Must use PascalCase (UpperCamelCase)
  - Examples: `PostRepository`, `GetPostsUseCase`, `MainActivity`
- **Functions, Variables, and Properties**: Must use camelCase (lowerCamelCase)
  - Examples: `getPosts()`, `userName`, `isLoading`
- **Constants**: Must use UPPER_SNAKE_CASE
  - Examples: `MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT`
- **Packages**: Must use lowercase with dots
  - Examples: `com.tumusx.multiplatform.domain.usecase`

If naming violations are found:
- Comment on each violation with the correct naming pattern
- Provide the corrected name suggestion
- Mark as **blocking** if the violation significantly impacts code readability

---

### Clean Code
Evaluate and comment on:
- Naming clarity and intention-revealing identifiers (following the naming conventions above)
- Function and class responsibilities (single responsibility principle)
- Code readability and maintainability
- Reduction of unnecessary complexity
- Proper use of immutability and explicit types
- Removal of dead, duplicated, or misleading code

You MAY:
- Propose large refactors
- Suggest splitting or merging classes/files
- Suggest rewriting functions or modules for clarity

---

### Clean Architecture
Evaluate and comment on:
- Clear separation of concerns
- Responsibility boundaries across modules and layers
- Direction of dependencies (core/business logic must not depend on platform or UI)
- Proper isolation of platform-specific code
- Testability and independence of business logic

You MAY:
- Propose architectural changes
- Suggest moving code across layers or modules
- Recommend introducing new abstractions or removing incorrect ones
- Suggest restructuring files or packages when beneficial

You SHOULD:
- Clearly explain the motivation and benefits of major changes
- Prefer correctness, clarity, and long-term maintainability over minimal diffs

---

### Unit Testing Requirements
**MANDATORY** - Always check and enforce:

#### Test Coverage for Simple Methods
For each **simple method** in the PR, verify that unit tests exist:

**Simple methods** are defined as methods that:
- Perform data transformations or calculations
- Have clear input/output without complex dependencies
- Can be tested in isolation
- Examples: data mappers, validators, formatters, simple business logic

#### If Tests Are Missing:
1. **Identify the gap**: Comment which simple methods lack unit tests
2. **Implement the tests**: Automatically generate and add unit tests for these methods
3. **Test Structure**: Follow existing test patterns in the codebase
   - Use `kotlin.test` framework for Kotlin Multiplatform
   - Place tests in `commonTest` for shared code
   - Use descriptive test names following pattern: `methodName_scenario_expectedResult`
   - Example: `getPosts_whenRepositoryReturnsData_shouldReturnSuccess()`

#### Test Quality Standards:
- Each test should test ONE specific behavior
- Use proper arrange-act-assert pattern
- Mock external dependencies appropriately
- Test both success and failure scenarios
- Verify edge cases when applicable

#### Implementation Process:
When you find simple methods without tests:
1. Create test file if it doesn't exist (e.g., `GetPostsUseCaseTest.kt`)
2. Add test cases covering:
   - Happy path (expected behavior)
   - Error cases (exceptions, null values)
   - Edge cases (empty lists, boundary values)
3. Comment in the review about the tests you've added

---

### Review Focus
- Identify blocking issues clearly
- Distinguish between required changes and optional improvements
- Be explicit when a PR requires significant rework before approval
- **Check naming conventions compliance** (PascalCase for classes, camelCase for methods/properties)
- **Verify unit tests exist for all simple methods** - implement them if missing
- If the code meets Clean Code, Clean Architecture, Naming Conventions, and Testing standards, explicitly approve the PR from a quality perspective
